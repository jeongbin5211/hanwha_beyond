프로젝트 진행 과정

계획 > 분석 > 설계 > 구현 > 시험 > 유지보수
-> 요즘은 에자일 방법론으로 개발함 - 위 사이클을 주 단위 식으로 짧게 반복

이런 과정 전체에 형상 관리(버전 관리)를 진행

1. 계획

1) 타당성 분석
 - 경제적, 기술적, 법적

2) 프로젝트 계획서 작성(O)
 - 프로젝트 범위, 자원 점검(HW 사양, OS 버전, SW), 인원, 예산, 일정
 - 어느정도의 사용자가 있을지, 트래픽 처리를 어떤식으로 할건지
 - 스프링을 왜 사용했는지
 - db는 왜 해당 db를 사용했는지
 - 결국 모든걸 왜 그 기술 스택을 썼는지 생각해야함 


3) 팀구성(O)
 - 민주적(=분산형), 중앙집중형, 혼합형, 계층형

4) 계발 비용 산정

5) 프로젝트 스케쥴링(O)
 - 소작업 분해 > WBS > CPM > 최소 비용 산정 > CPM 수정 > 간트 차트
   (마인드맵)

2. 분석

1) 요구사항분석(O)

3. 설계

1) 아키텍처
인프라 : 시스템 아키텍처
프론트 엔드 : UI/UX 설계도, SW 아키텍처
백엔드 : API 명세서, ERD, SW 아키텍처

4. 구현

5. 테스트/시험

TDD
 - 모든 상황을 커버하기 위함(커버리지)

장점 : 단위 테스트가 용이하다, 자동화 시스템에서 테스트를 자동으로 돌릴수 있게 할 수 있고 테스트가 통과해야 업로드가 되어서 좋음

6. 유지보수

개발이 끝난 후 서비스를 운영하면서 기능을 추가하거나 에러를 잡는 일

-> 로그인 시스템을 공부해 보았고 실무때 구현했던 로그인 시스템과 얼마나 차별점이 있는지
-> 데드락을 경험해봤는데 서버를 접하지 못해서 해결해보지 못했다.
-> 상상하면서 개발해봄

git

1) git이란?
git은 내 컴퓨터에 설치되는 프로그램
형상관리를 해주는 프로그램

git이란 소스코드를 효과적으로 관리하기 위해 개발된 분산형 버전 관리 시스템
git에서는 소스 코드가 변겨오딘 이력을 쉽게 확인할 수 있고
특정 시점에 저장된 버전과 비교하거나 특정 시점으로 되돌아갈 수 있다.
또 내가 올리려는 파일이 누군가 편집한 내용과 충돌한다면
서버에 업로드 할 때 경고 메시지가 발생함.

깃 설치 : 공홈에서 OS에 맞게 다운로드

2) 저장소
저장소(git repository)란 말그대로 파일이나 폴더를 저장해 두는 곳
그런데 Git 저장소에서는 파일이 변경 이력 별로 구분되어 저장된다.

깃의 작동 순서

git init

git add 파일 이름 : 스테이징 영역에 저장됨

git commit 로컬 저장소에 저장

git config --global user.email "이메일"
git config --global user.name "깃허브이름"

git rm --cached 파일 이름 : 해당 파일을 언트랙티드 상태로 만들어준다.

git commit -m "" : 로컬 저장소

git status : git 상태 확인(변경 내용이 있다면 캐치해줌)
	Untracked : 스테이징 영역에 추가되지 않은 상태
	Tracked : 스테이징 영역에 추가된 상태
	 Modified : 스테이징 영역에 있는 파일의 내용이 수정된 상태
	Unmodified : 수정된 내용을 다시 스테이징 영역에 추가한 상태

변경 사항 확인
git diff

이전 버전으로 되돌리기
git checkout 브랜치이름 : 주의 사항 : 이전 버전으로 가기 전에 반드시 최신 버전을 저장하고 이동할 것
git reset 커밋해시 : HEAD와 main이 같이 이동함

git log : 저장 내역 확인 (커밋 내역 확인)
	HEAD 현재 위치해있는 곳을 말해줌

깃 실습

V1
	a.txt 생성 및 내용 작성
V2
	atxt 내용추가
V3
	b.txt 생성 및 내용 작성
V4
	b.txt에 내용 추가

특정 커밋 상태로 가고싶을때 - git checkout (git log에서 나오는 commit 해시태그?)

git --all 하면 모든 버전을 볼 수 있음

다시 최신버전으로 가고싶을때도 git checkout 최근 커밋 입력

만약 새로운 내용을 커밋하지 않고 체크아웃을 한다면 해당 파일은 남아있기 때문에 문제가 생길 수 있다. -> 따라서 되도록이면 커밋을 하자

git reset 해시 

--hard : 작업 디렉토리 변경, 스테이징 영역 변경, 저장소 변경
--mixedd : 작업 디렉토리 유지, 스테이징 영역 변경, 

git comit --amend -m "" : 커밋 메세지 수정

실습2

새로운 프로젝트

이니셜로 된 폴더에 작업, 해당 폴더 버전 관리

User.txt 파일 생성 v1 저장

User.txt에 사용자 이름 3개 작성 v2 저장

User.txt에 사용자 이름 1개 추가  v3 저장

v2로 돌아가서 사용자 이름 1개 추가

-> git status 해보면 detached

이후 git add 후 커밋 v4 하면 HEAD 와 main이 따로있음

이렇게 되면 v4는 따로 저장이 된 상태라고 생각하면됨

detached 는 시간선 자체가 없으므로 이후 잘못하면 사라질 수 있다.

이후 git checkout master 해보면 v4는 없어져있음

git checkout -b 브랜치이름 : 브랜치를 새로 생성하고 해당 브랜치로 이동

정리 : checkout하면 혼자 이동, reset 하면 시간선 자체가 이동

브랜치

1) 브랜치 생성
git branch 브랜치이름
git branch 만 치면 브랜치 종류 나오고 현재 브랜치 말해줌

2) 브랜치 변환
git checkout 브랜치이름

3) 브랜치 병합
git checkout 브랜치이름 메인이 되는 브랜치
git merge 다른브랜치이름

4) 브랜치 충돌
충돌난 파일 내용 수정
git add 파일이름
git commit

브랜치 실습

1. git init
2. 아무 파일 생성 후 커밋 내역 1개 남기기
3. 브랜치 생성 - git branch branch name
4. 브랜치 확인 - git branch
5. 브랜치 변경 - git checkout branch
6. 내용 아무렇게나 수정해서 커밋 내역 1개 남기기
7. 메인 브랜치로 변경
8. 새 브랜치 생성
9. 또 새브랜치 생성
10. 새 브랜치로 변경
11. 내용 아무렇게나 수정해서 커밋 내역 1개 남기기

실습2

main을 복사한 develop 브랜치 생성
develop을 복사한 feature 브랜치들을 생성

이후 feature/member 를 develop 에 merge 하고, feature/product를 merge 하고, 그 버전을 feature/order로 
checkout -b

이후 order에 README.md 추가, order.txt 추가 후 checkout으로 develop
develop에서 README.md 다른내용으로 추가 후 git merge feature/order 하면 conflict 발생

git + github

github 프로젝트 관리

마크다운 사용법

